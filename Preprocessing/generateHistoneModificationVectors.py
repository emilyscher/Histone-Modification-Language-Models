import os
from os import listdir
import random
import numpy as np

'''
This class finds which histone modifications overlap with which nucleosome 
vectors. The output is a list of histone modification vectors, where each 
0/1 value in each vector representst the absense/presence of a particular 
histone modification in that nucleosome.

The require files are:
-The genome sequence file, in fasta format
-The peak calling output files, generated by MACS 2, in .xls format
-The nucleosome position prediction file, generated by NSeq

The output of this class is a list of histone modification vectors. 
These vectors also have sequence base count information.

'''

chromToDNASeq = dict()

startFlag = False
seq = ""
chrom = ""

# get sequences together
# opens the human genome sequence file, creates a dictionary chromToDNASeq which stores the chromosome name mapped to its sequence
with open("GCF_000001405.39_GRCh38.p13_genomic.fna","r") as f:
    for line in f:
        line = line.strip()

        if ">" in line:
            if startFlag and len(chrom) > 0:
                chromToDNASeq[chrom] = seq
            seq = ""
            startFlag = False
            chrom = ""

        if "scaffold" not in line and "Primary Assembly" in line:
            startFlag = True
            split = line.split("chromosome ")
            chromNumber = split[1].split()[0]
            chrom = "chr" + chromNumber[:-1]
            seq = ""

        elif startFlag:
            seq = seq + line.upper()

    if startFlag and len(chrom) > 0:
        chromToDNASeq[chrom] = seq

f.close()

# small class for storing peaks
class Peak:
    def __init__(self, id, mark, firstCoord, secondCoord):
        self.id = id
        self.mark = mark
        self.firstCoord = int(firstCoord)
        self.secondCoord = int(secondCoord)

    def __repr__(self):
        return self.id + " " + self.mark + " " + self.firstCoord + " " + self.secondCoord


# useful method for checking if value can be processed as a number
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

fileId = 0

chromosome_dict = dict()

marks = set()

markIndicies = dict()
currentMarkIndex = 0


sequence = [[]]

# open all relevant histone modification peak files, which have previously been generated by MACS 2
for file in os.listdir("."):
    # we're only interested in K562 sequences, and the peaks are stored in .xls format
    if(".xls" in file and "K562" in file):

        # open the file
        with open(file,"r") as f:
            fileId = fileId + 1
            for line in f:
                if('#' not in line and 'start' not in line):
                    split = line.split()
                    if(len(split) > 1):
                        if split[0] not in chromosome_dict.keys():
                            chromosome_dict[split[0]] = list()
                        firstCoord = int(split[1])
                        secondCoord = int(split[2])

                        if int(split[1]) > int(split[2]):
                            firstCoord = int(split[2])
                            secondCoord = int(split[1])
                        

                        #we only want the K562 strain, and only want histone marks and Pol2
                        mark = file.split("K562")[1]
                        if(((mark[0] == "H" or mark[0] == "h") and is_number(mark[1]))):
                            mark = mark.split("StdAln")[0]
                            
                            marks.add(mark)
                            if(mark not in markIndicies.keys()):
                                markIndicies[mark] = currentMarkIndex
                                currentMarkIndex+=1

                            # create a new peak object, and store it
                            peak = Peak(split[9], mark, str(firstCoord), str(secondCoord))
                            chromosome_dict[split[0]].append(peak)

        f.close()

# sort all of the marks by their first coordinate
for chrom in chromosome_dict:
    print(chrom + "\t" + str(len(chromosome_dict[chrom])))

    prev = None
    chromosome_dict[chrom].sort(key=lambda x: x.firstCoord, reverse=False)

    for mark in chromosome_dict[chrom]:
        if prev == None:
            prev = mark
        else:
            if mark.firstCoord < prev.firstCoord:
                print("NOT IN ORDER")
            prev = mark

#at this point, all of the marks have been binarised and put into a dict. now we need to read in the nucleosome positions and assign them their marks

# method for checking if a mark is overlapping a nucleosome using the nucleosome's midpoint
def overlapping(mark, strMidpoint):
    nucleosomeSize = 148
    halfSize = nucleosomeSize/2

    midpoint = int(strMidpoint)
    
    nucStart = midpoint - halfSize
    nucEnd = midpoint + halfSize

    # mark is fully contained within nucleosome
    if(mark.firstCoord >= nucStart and mark.secondCoord <= nucEnd):
        return True

    #mark starts before the nucleosome but overlaps it
    if(mark.firstCoord <= nucStart and mark.secondCoord >= nucStart):
        return True

    #mark ends after the nucleosome but overlaps it
    if(mark.firstCoord <= nucEnd and mark.secondCoord >= nucEnd):
        return True

    #mark is bigger than the nucleosome and starts before and ends after it
    if(mark.firstCoord <= nucStart and mark.secondCoord >= nucEnd):
        return True

    return False

# utility for getting a formatted string representing a list of marks
def format(marks):
    total = ""
    for mark in marks:
        total = total + mark + ", "

    return total

currentChrom = ""
count = 0

#generate output file of nucleosomes/marks
with open("../assignNucleosomePositions/experiment.bam_NSeq_10.26.2018_18.03.11.txt","r") as f:
    for line in f:
        # split the line by whitespace
        split = line.split()

        # if its the right kind of line
        if len(split) >= 2 and "#" not in line:
            chrom = split[0]

            # remove this to generate the vectors for every chromosome
            if chrom == "chr9":
                midpoint = split[1]

                # a new chromosome
                if currentChrom != chrom:
                    currentChrom = chrom
                    count = 1
                # otherwise, still the same chromosome
                else:
                    count = count + 1
                
                overlappingMarks = list()
                nucStart = str(int(midpoint) - 75)
                nucEnd = str(int(midpoint) + 75)

                notOverlappingCount = 0
                startCountingOverlaps = False

                # find all overlapping marks
                for mark in chromosome_dict[chrom]:
                    if overlapping(mark, midpoint):
                        startCountingOverlaps = True
                        overlappingMarks.append(mark.mark)
                    elif startCountingOverlaps:
                        notOverlappingCount = notOverlappingCount + 1

                    # if we haven't seen anything overlapping for a long time, 
                    # we can assume we've found everything relevant already and can move on
                    if notOverlappingCount > 100:
                        break


                vectorString = "000000000000"

                # generate vector string
                for mark in overlappingMarks:
                    vectorString = vectorString[:markIndicies[mark]] + "1" + vectorString[markIndicies[mark] + 1:]

                # get this nucleosome's associated sequence
                seq = chromToDNASeq[chrom][int(nucStart)-1:int(nucEnd)-1]

                # get the base counts
                a = 0
                t = 0
                c = 0
                g = 0
                for char in seq:
                    if char == "A":
                        a = a + 1
                    if char == "T":
                        t = t + 1
                    if char == "C":
                        c = c + 1
                    if char == "G":
                        g = g + 1

                countString = str(a) + "," + str(t) + "," + str(c) + "," + str(g)

                # print the data for this nucleosome
                print(str(count) + "\t" + chrom +"\t" + midpoint + "\t" + vectorString + "\t" + countString)
            
